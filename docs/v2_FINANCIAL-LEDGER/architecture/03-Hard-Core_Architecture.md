## 📄 시스템 탄력성 및 하드코어 아키텍처 (System Resilience & Hard-Core Architecture)

이 문서는 **Fieldstack** 프로젝트의 메인 코어 엔진을 보호하고, 장애 발생 시 자동으로 시스템을 복구하며 사용자에게 상태를 알리는 **하드코어(Hard-Core)** 계층의 설계와 동작 방식을 정의합니다.

---

### 1. 설계 철학 (Design Philosophy)

* **Layered Defense:** 시스템을 비즈니스 로직(Core)과 감시 계층(Hard-Core)으로 분리하여, 코어가 마비되어도 시스템 제어권을 유지합니다.
* **Fail-Fast & Auto-Recovery:** 장애 발생 시 지체 없이 시스템을 재시작하여 가용성을 확보합니다.
* **User Transparency:** 시스템 장애 및 재부팅 과정을 사용자에게 실시간으로 공유하여 운영 신뢰도를 높입니다.

---

### 2. 아키텍처 구조 (System Layering)

| 계층 (Layer) | 역할 및 책임 | 비고 |
| --- | --- | --- |
| **Hard-Core** | 코어 엔진 감시, 프로세스 제어, 긴급 웹 알림, 사후 보고서 생성 | 안티치트와 유사한 감시 권한 |
| **Main Core** | 금융 원장 로직 처리, 이벤트 소싱 기록, API 응답 | 비즈니스 로직 실행부 |
| **Frontend** | 실시간 시스템 상태 표시, 장애 발생 시 로딩/복구 화면 전환 | 사용자 인터페이스 |

---

### 3. 장애 대응 및 자동 복구 시퀀스 (Recovery Sequence)

장애(락 걸림, 데드락, 패닉 등) 발생 시 하드코어는 다음의 **사전 제작된 로직(Pre-defined Logic)**에 따라 처리를 진행합니다.

1. **감지 (Detection):** 하드코어가 코어의 하트비트(Heartbeat) 중단 또는 트랜잭션 타임아웃을 감지합니다.
2. **긴급 알림 (Emergency Alert):** 하드코어가 직접 프론트엔드에 신호를 보내 사용자 화면을 '시스템 복구 중' 페이지로 강제 전환합니다.
3. **로그 기록 (Audit Logging):** 재부팅 전, 마지막 실행 시퀀스와 에러 지점의 메모리 스냅샷을 안전하게 파일로 덤프합니다.
4. **강제 재부팅 (Forced Reboot):** 코어 프로세스를 종료하고 내부 CLI를 통해 시스템을 즉시 재시작합니다.
5. **사후 보고 (Post-Mortem):** 시스템 재가동 후, 관리자 대시보드에 장애 원인 및 복구 성공 여부를 요약하여 표시합니다.

---

### 4. 하드코어 내장 주요 모듈

#### **4.1 Sentinel (감시자)**

* 메인 코어의 리소스 점유율과 응답성을 0.1초 단위로 체크합니다.
* 안티치트 기술처럼 코어의 비정상적인 동작이나 락 상태를 외부에서 관찰합니다.

#### **4.2 Crisis UX Controller**

* 코어가 응답 불능일 때 웹소켓(Websocket) 연결을 가로채거나 별도 채널로 사용자에게 상황을 전달합니다.
* 로딩 페이지 및 예상 복구 시간을 제공합니다.

#### **4.3 Post-Mortem Analyzer**

* 재부팅 후 로그를 분석하여 장애를 유발한 계정(Account)이나 트랜잭션 ID를 식별합니다.
* 분석 결과를 바탕으로 동일 장애 재발 방지 로직을 제안합니다.

---

### 5. 기대 효과

* **운영 편의성:** 개인 서버 운영자가 수동으로 락을 풀거나 서버를 껐다 켤 필요가 없습니다.
* **데이터 무결성:** 하드코어의 통제하에 안전하게 종료되므로 이벤트 기록의 유실을 최소화합니다.
* **신뢰도 향상:** 시스템 장애 상황에서도 사용자에게 친절한 가이드를 제공하여 전문적인 서비스 인상을 줍니다.

---

### 6. 향후 과제

* [ ] 하드코어와 코어 간의 전용 통신 채널(IPC) 최적화
* [ ] 무한 재부팅 방지를 위한 '데드 레터 큐(Dead Letter Queue)' 로직 구현
* [ ] 웹 대시보드 내 사후 보고서 UI 디자인