# 핵심 아키텍처 결정 사항

> 이 문서는 Fieldstack의 핵심 설계 결정 사항을 기록합니다.  
> 모든 개발과 문서는 이 결정을 기반으로 진행됩니다.

**최종 업데이트:** 2025-01-29  
**문서 버전:** 1.0.0

---

## 📌 결정 원칙

프로젝트의 모든 기술적 결정은 다음 원칙을 따릅니다:

1. **단순함 우선** - 복잡한 것보다 작동하는 단순한 것
2. **사용자 경험** - 개발자가 아닌 일반 사용자 관점
3. **유지보수성** - 10년 후에도 이해 가능한 코드
4. **점진적 개선** - 완벽보다 작동하는 MVP
5. **명확한 문서** - 코드보다 문서가 먼저

---

## 결정 #1: Module Loader 방식

### ✅ 결정 사항

**런타임 동적 Import + Hot Reload 방식**을 채택합니다.

### 📖 배경

모듈 시스템은 본 프로젝트의 핵심 기능입니다. WordPress 플러그인이나 VSCode 확장처럼 사용자가 쉽게 기능을 추가/제거할 수 있어야 합니다.

### 🔍 고려했던 옵션

#### Option A: 런타임 동적 Import ⭐ (선택)
```
장점:
- 서버 재시작 불필요
- 사용자 경험 최상 (VSCode 방식)
- Hot Reload 가능

단점:
- 구현 복잡도 높음
- TypeScript 빌드 통합 필요
- 메모리 관리 주의
```

#### Option B: 빌드타임 번들링
```
장점:
- 구현 간단
- 안정적

단점:
- 모듈 추가 시 재빌드 필요
- 서버 재시작 필수
- 사용자 경험 나쁨
```

#### Option C: 플러그인 시스템
```
장점:
- 중간 복잡도

단점:
- Core의 Plugin과 혼동 가능
- 명확한 구분 어려움
```

### 💡 선택 이유

**Option A**를 선택한 이유:

1. **사용자 경험 최우선**
   - 모듈 설치 시 서버 재시작 불필요
   - 로딩 UI만 보다가 자동 새로고침
   - 사용자는 F5 누를 필요 없음

2. **VSCode 확장 방식**
   ```
   사용자: "확장 설치" 버튼 클릭
   → 백그라운드 다운로드 및 설치
   → "확장을 사용하려면 새로고침 필요" 알림
   → "새로고침" 버튼 클릭
   → 즉시 사용 가능
   ```

3. **명확한 역할 분리**
   - **Module**: 사용자가 설치하는 기능 (Ledger, TODO 등)
   - **Plugin**: Core 내부 시스템용 (Scheduler, AI 등)

### 🎯 구현 방향

#### 사용자 관점 플로우
```
1. 마켓플레이스에서 "설치" 버튼 클릭
   ↓
2. 모달 표시: "설치 중..." (진행률 표시)
   ↓
3. Backend 백그라운드 작업:
   - Git clone
   - 보안 검사
   - npm install
   - DB 마이그레이션
   - 런타임 로드
   ↓
4. WebSocket으로 Frontend에 알림
   ↓
5. "설치 완료! 새로고침 중..." 자동 새로고침
   ↓
6. 새 모듈이 메뉴에 표시됨
```

#### 기술 구현 방향

ModuleLoader 클래스는 모듈 설치와 로드의 전체 파이프라인을 담당합니다.

installAndLoad 메서드는 모듈 설치를 총 6단계로 처리합니다. 첫째로 모듈을 다운로드하고 보안 검증을 실행합니다. 둘째로 의존성을 설치합니다. 셋째로 DB 마이그레이션을 실행합니다. 넷째로 런타임에 모듈을 동적으로 로드합니다. 다섯째로 라우트를 등록합니다. 여섯째로 Frontend에 'module:installed' 이벤트를 WebSocket으로 알림합니다.

reloadModule 메서드는 개발 모드에서 사용되는 Hot Reload 기능입니다. 기존 모듈을 먼저 정리한 후, require.cache를 제거하고 모듈을 다시 로드합니다.

### 📚 관련 문서

> 📖 **상세 구현 가이드:**  
> → `technical/module-loader.md` (작성 예정)

> 📖 **모듈 개발 가이드:**  
> → `modules/01-development-guide.md`

> 📖 **사용자 설치 가이드:**  
> → `marketplace/02-installation.md`

### ⚠️ 주의사항

1. **메모리 누수 방지**
   - `require.cache` 적절히 관리
   - 모듈 unload 시 이벤트 리스너 제거

2. **보안**
   - 모듈 설치 전 항상 검증
   - 악성 코드 패턴 스캔

3. **에러 처리**
   - 설치 실패 시 자동 롤백
   - 사용자에게 명확한 에러 메시지

---

## 결정 #2: 관리자 인증 방식

### ✅ 결정 사항

**Google OAuth + 4~6자리 PIN** 방식을 채택합니다.

### 📖 배경

시스템에는 두 가지 수준의 접근이 필요합니다:
- **일반 접근**: 앱 사용 (가계부 입력 등)
- **관리자 접근**: 중요 설정 변경 (사용자 관리, DB 설정 등)

### 🔍 고려했던 옵션

#### Option A: OAuth + 복잡한 비밀번호
```
장점:
- 높은 보안

단점:
- 홈서버 환경에 과도함
- 사용자 혼란 (OAuth 비번? 관리자 비번?)
- 관리 복잡
```

#### Option B: OAuth + Role만
```
장점:
- 매우 간단

단점:
- 보안 부족
- 관리자 설정 보호 안 됨
```

#### Option C: OAuth + PIN ⭐ (선택)
```
장점:
- 간단하면서 적절한 보안
- 홈서버 환경에 적합
- 스마트폰 잠금 화면과 유사한 UX

단점:
- 복잡한 비밀번호보다는 보안 낮음
```

#### Option D: OAuth + 2FA
```
장점:
- 매우 높은 보안

단점:
- 홈서버에 과도함
- 구현 복잡도 높음
```

### 💡 선택 이유

**Option C**를 선택한 이유:

1. **적절한 보안 수준**
   - 홈서버 환경: 물리적 보안 + OAuth + PIN으로 충분
   - 4~6자리로도 충분한 보호
   - 30분 세션으로 재입력 최소화

2. **사용자 친화적**
   - 간단히 외울 수 있는 숫자
   - 스마트폰 잠금과 동일한 UX
   - 숫자 패드로 빠른 입력

3. **구현 단순성**
   - bcrypt/pbkdf2로 안전하게 저장
   - 세션 관리 간단
   - 2FA보다 복잡도 낮음

### 🎯 구현 방향

#### 사용자 플로우

```
일반 사용:
  Google 로그인 → 앱 사용 (가계부 입력 등)

관리자 설정 접근:
  Google 로그인 (이미 됨)
    ↓
  관리자 설정 메뉴 클릭
    ↓
  PIN 입력 모달 표시
    ↓
  PIN 확인
    ↓
  30분간 관리자 권한 (세션)
    ↓
  브라우저 닫거나 30분 후 → 다시 PIN 입력
```

#### 기술 구현

AdminAuthService 클래스는 관리자 PIN 인증을 담당합니다.

setupAdminPin 메서드는 초기 설치 시 관리자 PIN을 생성합니다. 먼저 PIN이 4~6자리 숫자인지 정규식으로 검증합니다. 통과하면 무작위 16바이트의 salt를 생성하고, PIN과 salt를 합쳐 pbkdf2로 10000회 반복 해싱합니다. 그 결과를 사용자 테이블에 role, salt, hash와 함께 저장합니다.

verifyAndCreateSession 메서드는 PIN 검증과 세션 생성을 처리합니다. verifyPin을 호출하여 PIN이 올바른지 확인합니다. 검증 실패 시 감사 로그를 남기고 에러를 발생시킵니다. 검증 성공 시 무작위 UUID를 세션 ID로 생성하고, 현재 시간에서 30분을 더한 만료 시간과 함께 세션을 저장합니다.

#### UI 구현

AdminPinModal은 관리자 인증 모달 컴포넌트입니다. '🔐 관리자 인증' 제목과 안내 문자열을 표시하고, PinInput 컴포넌트로 숫자 패드 형태의 PIN 입력 UI를 제공합니다. 6자리가 입력되면 자동으로 handleVerify를 호출합니다. 하단에는 '이 인증은 30분간 유효합니다' 안내가 표시됩니다.

### 🔒 보안 강화

Rate Limiting은 5회 연속 실패 시 5분간 로그인을 잠급니다. 잠금 창은 5분(밀리초 환산)입니다.

감사 로그는 각 PIN 검증 시도마다 사용자 ID, 성공/실패 여부, IP 주소, 타임스탬프를 기록합니다.

### 📚 관련 문서

> 📖 **상세 인증 가이드:**  
> → `technical/02-authentication.md § 3. 관리자 인증`

> 📖 **보안 정책:**  
> → `security/access-control.md` (작성 예정)

### ⚠️ 주의사항

1. **Rate Limiting 필수**
   - 5회 실패 → 5분 잠금
   - 감사 로그 기록

2. **세션 관리**
   - 30분 타임아웃
   - 브라우저 닫으면 삭제
   - 만료된 세션 자동 정리

3. **선택적 강화**
   - 필요시 2FA 추가 가능 (고급 옵션)
   - PIN 변경 주기 알림 (선택)

---

## 결정 #3: DB 추상화 레벨

### ✅ 결정 사항

**Query Builder 방식**의 중간 레벨 추상화를 채택합니다.

### 📖 배경

다양한 DB(PostgreSQL, SQLite, Supabase, MongoDB)를 지원하면서도:
- 모듈 개발자가 쉽게 사용할 수 있어야 함
- "알잘딱하게 잘 작동"해야 함
- 복잡한 ORM은 피하고 싶음

### 🔍 고려했던 옵션

#### Option A: Raw SQL + Provider별 구현
```
장점:
- 완전한 제어
- 성능 최고

단점:
- DB별 SQL 차이 처리 복잡
- 모듈 개발자 부담 큼
```

#### Option B: ORM (Prisma, TypeORM)
```
장점:
- 타입 안전
- 자동 마이그레이션

단점:
- 무거움
- 학습 곡선
- 오버헤드
```

#### Option C: Query Builder ⭐ (선택)
```
장점:
- 적절한 추상화
- 가벼움
- 유연함
- 직관적

단점:
- 직접 구현 필요
```

### 💡 선택 이유

**Option C**를 선택한 이유:

1. **적절한 추상화 레벨**
   - Raw SQL보다 안전하고 간편
   - ORM보다 가볍고 이해하기 쉜음
   - 필요 시 Raw SQL 직접 사용 가능

2. **모듈 개발자 친화적**

   사용법은 간단하고 직관적입니다. db.table('ledger_entries')에서 테이블을 지정하고, .where로 user_id 조건을 추가하고, .orderBy로 날짜 내림차순 정렬, .limit으로 50건 제한한 후 .get()으로 실행하면 결과를 받습니다.

3. **다양한 DB 지원**
   - 각 Provider가 Query Builder를 SQL로 변환
   - PostgreSQL: `$1, $2` 플레이스홀더
   - SQLite: `?, ?` 플레이스홀더
   - MongoDB: Query Object로 변환

### 🎯 구현 방향

#### Query Builder API

DBClient 인터페이스는 두 가지 주요 기능을 제공합니다. table 메서드는 테이블 이름을 받아 QueryBuilder를 반환합니다. query 메서드는 Raw SQL과 파라미터를 받아 직접 실행할 수 있습니다. 트랜잭션은 transaction 메서드로 처리되며, 콜백 안에서 실행된 작업들이 하나로 묶입니다.

QueryBuilder 클래스는 Knex 스타일의 체이닝 API를 제공합니다. select로 컬럼을 지정하고, where로 조건을 추가하고, orderBy로 정렬, limit과 offset으로 페이지네이션을 적용합니다. 실행은 get(목록), first(단일 항목), insert(삽입), update(수정), delete(삭제) 메서드로 합니다.

#### 사용 예시

getLedgerEntries 함수는 간단한 조회입니다. ledger_entries 테이블에서 user_id와 날짜 조건으로 필터링하고, 날짜 내림차순으로 50건까지 조회합니다.

createEntry 함수는 삽입입니다. 입력된 데이터에 created_at과 updated_at을 현재 시간으로 추가하여 테이블에 삽입합니다.

updateEntry 함수는 수정입니다. id 조건으로 해당 항목을 찾아 새 데이터로 업데이트합니다.

복잡한 쿼리는 Raw SQL을 사용합니다. 예시로 카테고리별 금액 합계를 구하는 쿼리가 있으며, GROUP BY와 SUM을 사용합니다. 파라미터 바인딩으로 SQL Injection을 방지합니다.

#### Provider 구현

PostgresProvider는 Query Builder를 PostgreSQL SQL로 변환합니다. WHERE 절에서 `$1, $2` 형태의 플레이스홀더를 사용하고, INSERT에서는 RETURNING *를 사용하여 삽입된 행을 반환합니다.

SQLiteProvider는 Query Builder를 SQLite SQL로 변환합니다. WHERE 절에서 `?, ?` 형태의 플레이스홀더를 사용하고, INSERT에서는 LAST_INSERT_ROWID()를 사용합니다.

MongoDBProvider는 Query Builder를 MongoDB Query Object로 변환합니다. 예시로 userId와 날짜 조건은 `{ userId: xxx, date: { $gte: xxx } }` 형태로 변환됩니다.

### 📚 관련 문서

> 📖 **상세 DB 가이드:**  
> → `technical/01-database.md § 2. DB 추상화`

> 📖 **Provider 개발:**  
> → `technical/database-providers.md` (작성 예정)

> 📖 **마이그레이션:**  
> → `technical/migrations.md` (작성 예정)

### ⚠️ 주의사항

1. **트랜잭션 사용**

   트랜잭션은 여러 작업을 하나로 묶어 원자성을 보장합니다. 예시로 entries 테이블에 삽입하고 accounts 테이블의 잔액을 업데이트하는 두 작업이 있으며, 하나라도 실패하면 두 작업 모두 되돌려집니다.

2. **SQL Injection 방지**
   - 항상 파라미터 바인딩 사용
   - Raw SQL 사용 시 주의

3. **성능**
   - 복잡한 Join은 Raw SQL 권장
   - N+1 문제 주의

---

## 📝 요약표

| 결정 | 선택 | 핵심 이유 | 상태 |
|------|------|----------|------|
| #1 Module Loader | 런타임 동적 Import | VSCode 방식 UX | ✅ 확정 |
| #2 관리자 인증 | OAuth + PIN | 간단하면서 안전 | ✅ 확정 |
| #3 DB 추상화 | Query Builder | 적절한 레벨 | ✅ 확정 |

---

## 🔄 변경 이력

| 날짜 | 버전 | 변경 내용 |
|------|------|----------|
| 2025-01-29 | 1.0.0 | 최초 작성 (#1, #2, #3) |

---

## 📌 다음 단계

### 즉시 진행 (Step 1)
- ✅ 핵심 결정 사항 문서화 완료
- 🔄 기존 문서에 교차 참조 추가 시작

### 문서 정리 (Step 3)
1. `architecture/00-overview.md` - Frontend 서빙 로직 명확화
2. `technical/02-authentication.md` - OAuth + PIN으로 수정
3. `modules/01-development-guide.md` - 교차 참조 추가

### 구현 시작 (Step 2)
- 문서 정리 완료 후 코어 구현 시작

---

> 💡 **중요:**  
> 이 문서의 결정사항은 프로젝트 전반에 영향을 미칩니다.  
> 변경이 필요한 경우 반드시 문서를 업데이트하고 버전을 올립니다.