# 인증 및 접근 제어

> 📌 **핵심 결정:**  
> → `architecture/decisions.md § 결정 #2: 관리자 인증 (OAuth + PIN)`

**최종 업데이트:** 2025-01-29

---

## 인증 방식

### Google OAuth 2.0

**일반 로그인:**
- Google 계정으로 로그인
- 일상적인 사용
- Whitelist 기반 접근 제어

**설정 방법:**
1. Google Cloud Console 접속
2. OAuth 2.0 클라이언트 ID 생성
3. 리다이렉트 URI 등록: `{YOUR_DOMAIN}/auth/callback`
4. Client ID와 Secret을 설정에 입력

---

## 관리자 인증 (PIN)

> 💡 **왜 PIN을 선택했나요?**  
> → `architecture/decisions.md § 결정 #2` - 설계 근거 참고

### 개념

**이중 인증 구조:**
```
일반 사용:
  Google OAuth → 앱 접근

관리자 설정 접근:
  Google OAuth → 앱 접근
       +
  4~6자리 PIN → 관리자 설정 접근
```

### 용도

**PIN이 필요한 페이지:**
- ⚙️ 사용자 관리 (Whitelist 추가/제거)
- 🗄️ 데이터베이스 설정 변경
- 🔧 시스템 설정 변경
- 📦 모듈 레지스트리 관리
- 🔐 보안 설정

**PIN이 불필요한 페이지:**
- 👤 일반 설정 (프로필, 테마 등)
- 📦 모듈 설치/제거 (사용자 본인)
- 🤖 AI 설정 (본인 API Key)
- 🔗 통합 서비스 설정 (본인 계정)

### 사용 시나리오

```
1. Google로 이미 로그인된 상태
   ↓
2. 관리자 설정 페이지 접근 시도
   (예: 사용자 관리, DB 설정, 시스템 설정)
   ↓
3. PIN 입력 화면 표시
   ┌─────────────────────────┐
   │   🔒 관리자 인증         │
   │                         │
   │   PIN: [□][□][□][□]    │
   │                         │
   │   [취소]  [확인]        │
   └─────────────────────────┘
   ↓
4. PIN 확인
   ↓
5. 설정 페이지 접근 허용 (30분간 유효)
```

### PIN 요구사항

**길이:**
- 4~6자리 숫자
- 권장: 6자리

**보안:**
- 최소 4자리 (홈서버 환경에 적합)
- 최대 6자리 (충분한 보안)
- 연속된 숫자 금지 (예: 1234, 9876)
- 반복된 숫자 금지 (예: 1111, 2222)

**저장:**
- PBKDF2 해싱 (100,000 iterations)
- Salt 추가

---

## 접근 제어

### Whitelist 기반

**작동 방식:**
```
1. 사용자가 Google로 로그인
   ↓
2. 이메일 주소 확인
   ↓
3. allowed_users 테이블에서 검색
   ↓
4. 있으면 → 접근 허용
   없으면 → 접근 거부
```

### 데이터베이스 스키마

allowed_users 테이블을 생성합니다. 고유 식별자인 id, 중복 불가능한 이메일 주소, 역할(기본값 'user'), 관리자 PIN의 해시값(PBKDF2로 암호화된 값), 추가한 관리자의 ID, 추가 시간, 마지막 로그인 시간 열이 있습니다.

admin_sessions 테이블은 관리자 PIN 인증 후 생성되는 임시 세션을 저장합니다. 세션 ID, 사용자 ID, 만료 시간, 생성 시간이 있으며, 한 사용자당 세션은 하나만 존재할 수 있습니다.

**역할 (Role):**
- `admin` - 전체 권한 + PIN 설정 가능
- `user` - 일반 사용자

---

## 인증 플로우

### 1. 로그인 프로세스

```
사용자 → "Google로 로그인" 버튼 클릭
         ↓
  Google OAuth 페이지로 리다이렉트
         ↓
  사용자가 Google 계정으로 로그인
         ↓
  권한 승인 (프로필, 이메일)
         ↓
  Callback URL로 리다이렉트 (Authorization Code)
         ↓
  Backend에서 Code → Access Token 교환
         ↓
  Google API로 사용자 정보 조회
         ↓
  이메일 주소 Whitelist 확인
         ↓
  JWT 토큰 발급 → 클라이언트에 전달
         ↓
  메인 화면으로 이동
```

### 2. 세션 관리

**JWT 기반:**

JWT 토큰의 내부 구조(Payload)는 다음과 같습니다. 사용자의 고유 ID, 이메일, 역할을 포함하고, 발급 시간(iat)과 만료 시간(exp)도 함께 저장됩니다. 만료 시간은 발급 시간 기준 7일 후입니다.

**저장 위치:**
- `httpOnly` Cookie (추천)
- 또는 LocalStorage (보안 주의)

**만료 시간:**
- Access Token: 7일
- Refresh Token: 30일 (선택)

---

## Backend 구현

### Express Middleware

authMiddleware는 모든 보호된 API 요청에 적용되는 인증 미들웨어입니다. 총 5단계로 진행됩니다. 첫째로 요청에서 토큰을 추출하고, 없으면 401 에러를 반환합니다. 둘째로 토큰의 유효성을 검증합니다. 셋째로 토큰에서 추출된 사용자 ID로 데이터베이스에서 사용자를 조회하고, 없으면 401 에러를 반환합니다. 넷째로 해당 사용자의 이메일이 Whitelist(allowed_users)에 있는지 확인하고, 없으면 403 에러를 반환합니다. 다섯째로 모든 검증이 통과하면 요청 객체에 사용자 정보를 추가하고 다음 단계로 넘깁니다.

### 관리자 PIN 인증

> 💡 **구현 상세:**  
> → `architecture/decisions.md § 결정 #2: 기술 구현`

AdminAuthService 클래스가 관리자 PIN 인증의 전체 흐름을 담당합니다.

hashPin 메서드는 PIN 문자열을 받아 무작위 Salt를 생성한 후 PBKDF2 알고리즘으로 100,000회 반복 해싱하여 안전한 해시값을 생성합니다. 해시값과 Salt를 함께 반환합니다.

verifyPin 메서드는 입력된 PIN과 저장된 해시값을 비교합니다. 저장된 해시값에서 Salt를 분리한 후, 같은 Salt로 입력 PIN을 다시 해싱하여 저장된 해시와 일치하는지 확인합니다.

createSession 메서드는 무작위 세션 ID를 생성하고, 현재 시간 기준 30분 후를 만료 시간으로 설정하여 admin_sessions 테이블에 저장합니다. 기존 세션이 있으면 새 세션으로 덮어씁니다.

verifySession 메서드는 세션 ID로 세션을 조회한 후, 존재하지 않거나 만료 시간이 지난 경우 false를 반환합니다. 만료된 세션은 즉시 삭제됩니다.

### API 엔드포인트

**PIN 설정 엔드포인트(POST /setup-pin):** 먼저 요청자가 관리자 역할인지 확인합니다. PIN이 4~6자리 숫자인지 검증하고, 연속된 숫자(예: 1234)나 반복된 숫자(예: 1111)인지도 체크합니다. 검증을 통과하면 PIN을 해싱하여 해시값과 Salt를 콜론(:)으로 구분하여 데이터베이스에 저장합니다.

**PIN 인증 엔드포인트(POST /verify-pin):** 관리자 권한을 확인한 후, 저장된 PIN 해시를 조회합니다. 입력된 PIN과 저장된 해시를 비교하여 검증합니다. 실패하면 감사 로그를 남기고 401 에러를 반환합니다. 성공하면 30분 유효한 세션을 생성하여 세션 ID를 반환합니다.

**관리자 설정 접근 미들웨어(requireAdminPin):** 기본 인증과 관리자 권한을 먼저 확인합니다. 요청 헤더에서 관리자 세션 ID를 추출하고, 없으면 PIN 입력이 필요하다는 응답을 반환합니다. 세션 ID가 있으면 유효성을 검증하고, 만료된 경우에도 PIN 입력을 다시 요구합니다. 검증이 통과하면 다음 단계로 넘깁니다.

---

## Frontend 구현

### PIN 입력 컴포넌트

> 💡 **UI 구현 예시:**  
> → `architecture/decisions.md § 결정 #2: UI 구현`

PinInput 컴포넌트는 사용자가 PIN을 입력하는 화면을 제공합니다. length 속성으로 PIN 자릿수(4 또는 6)를 설정할 수 있습니다.

각 자리마다 개별 입력란을 생성합니다. 숫자가 아닌 값은 입력할 수 없습니다. 숫자를 입력하면 자동으로 다음 입력란으로 포커스가 이동하고, Backspace를 누르면 이전 입력란으로 돌아갑니다. PIN의 모든 자리가 채워지면 onComplete 콜백을 실행하여 완성된 PIN을 전달합니다. 컴포넌트가 열리면 첫 번째 입력란에 자동으로 포커스됩니다. 에러 메시지가 있으면 입력란 아래에 빨간색으로 표시됩니다.

### PIN 인증 모달

AdminPinModal 컴포넌트는 관리자 PIN 입력을 위한 팝업입니다. PinInput 컴포넌트를 내부에 포함시킵니다.

PIN 입력이 완료되면 백엔드의 /api/admin/verify-pin에 요청을 보냅니다. 응답이 성공하면 반환된 세션 ID를 sessionStorage에 저장하고 onSuccess 콜백을 실행합니다. 실패하면 'PIN이 올바르지 않습니다' 에러 메시지를 표시합니다. 요청 중에는 '인증 중...' 로딩 메시지가 표시됩니다. 모달 하단에는 이 인증은 30분간 유효하다는 안내가 표시됩니다.

### Protected Admin Route

ProtectedAdminRoute 컴포넌트는 관리자 전용 페이지를 보호하는 라우트 래퍼입니다.

컴포넌트가 마운트되면 먼저 기존 관리자 세션이 있는지 확인합니다. sessionStorage에 저장된 세션 ID가 없으면 바로 PIN 모달을 표시합니다. 세션 ID가 있으면 백엔드에 세션 유효성 검증을 요청합니다. 유효하면 자식 컴포넌트를 렌더링하고, 유효하지 않으면 sessionStorage의 세션을 삭제하고 PIN 모달을 다시 표시합니다. PIN 인증이 성공하면 verified 상태를 켜고 모달을 닫습니다. 관리자가 아닌 사용자는 홈 페이지로 리다이렉트됩니다.

---

## 보안 고려사항

> 📖 **전체 보안 정책:**  
> → `architecture/decisions.md § 결정 #2: 보안`

### Rate Limiting

PIN 인증 엔드포인트에 속도 제한을 적용합니다. 5분 동안 5회 이상 실패하면 잠금됩니다. 성공한 요청은 실패 횟수에서 제외됩니다.

### 감사 로그

logFailedAttempt 함수는 PIN 인증 실패 시 사용자 ID, 실패 액션, IP 주소와 시간을 감사 로그 테이블에 기록합니다. 기록 후 최근 5분간의 연속 실패 횟수를 조회하여, 5회 이상이면 관리자에게 '관리자 PIN 접근 실패 다수 발생' 경고 알림을 보냅니다.

### 세션 타임아웃

관리자 세션은 30분 동안 사용되지 않으면 자동으로 만료됩니다. 세션을 생성하거나 갱신할 때마다 만료 시간을 현재 시간 기준 30분 후로 재설정합니다.

### PIN 변경

현재 PIN과 새 PIN을 모두 받습니다. 먼저 현재 PIN이 올바른지 검증합니다. 올바르지 않으면 401 에러를 반환합니다. 올바르면 새 PIN을 해싱하여 저장한 후, 해당 사용자의 모든 관리자 세션을 무효화합니다.

---

## Google OAuth 콜백 처리

GET /auth/google 엔드포인트는 사용자를 Google의 OAuth 인증 페이지로 리다이렉트합니다. 프로필과 이메일 정보에 대한 권한을 요청합니다.

GET /auth/callback 엔드포인트는 Google에서 돌아온 콜백을 처리합니다. 총 7단계로 진행됩니다. 첫째로 Google에서 반환된 Authorization Code를 Access Token으로 교환합니다. 둘째로 Access Token으로 사용자의 프로필 정보를 조회합니다. 셋째로 조회된 이메일이 Whitelist에 있는지 확인하고, 없으면 접근 거부합니다. 넷째로 사용자가 이미 존재하면 마지막 로그인 시간과 프로필 사진을 업데이트하고, 없으면 새로 생성합니다. 다섯째로 사용자 ID, 이메일, 역할로 JWT 토큰을 생성합니다. 여섯째로 생성된 토큰을 httpOnly Cookie로 저장하며, 프로덕션 환경에서는 secure 플래그도 활성화하고, 만료 시간은 7일로 설정합니다. 일곱째로 메인 화면으로 리다이렉트합니다.

---

## 로그인

**Backend:** POST /auth/logout 엔드포인트는 관리자인 경우 해당 사용자의 모든 관리자 세션을 삭제한 후, auth_token 쿠키를 삭제합니다.

**Frontend:** 로그아웃 버튼을 클릭하면 백엔드의 로그아웃 엔드포인트에 요청을 보냅니다. 완료되면 sessionStorage의 관리자 세션도 삭제하고, 로그인 페이지로 이동합니다.

---

## 📚 관련 문서

- 📌 `architecture/decisions.md § 결정 #2` - PIN 방식 선택 근거
- 📖 `deployment/setup-wizard.md` - 초기 관리자 설정
- 📖 `community/github-policy.md` - 보안 정책

---

## FAQ

### Q1. 왜 비밀번호가 아니라 PIN인가요?
**A:** 홈서버 환경에서는 스마트폰 잠금처럼 간단한 PIN이 더 적합합니다. 복잡한 비밀번호는 자주 입력해야 하는 관리자 설정에 부담이 됩니다.

> 📖 상세 이유: `architecture/decisions.md § 결정 #2`

### Q2. PIN이 안전한가요?
**A:** PBKDF2 + Rate Limiting으로 충분히 안전합니다. 5회 실패 시 5분 잠금되므로 브루트포스 공격이 어렵습니다.

### Q3. PIN을 잊어버렸어요!
**A:** 데이터베이스에서 직접 초기화해야 합니다. 백업 관리자 계정을 미리 만들어두는 것을 권장합니다.

### Q4. 세션이 자주 만료돼요
**A:** 30분 타임아웃은 보안을 위한 것입니다. 설정에서 조정 가능합니다 (권장하지 않음).

### Q5. 일반 사용자도 PIN이 필요한가요?
**A:** 아니요. PIN은 관리자 설정에만 필요합니다. 일반 사용자는 Google OAuth만으로 충분합니다.